<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Mini Jump 'n' Run ‚Äì Mobile</title>
  <style>
    html, body { margin: 0; height: 100%; background:#111; color:#eee; font-family: system-ui, Arial, sans-serif; touch-action: none; }
    #wrap { display:flex; flex-direction:column; align-items:center; gap:8px; padding:10px 0; height:100%; box-sizing:border-box;}
    canvas { background: linear-gradient(#78c0ff, #b1e1ff 40%, #87d37c 40%, #6ab04c);
             border:2px solid #222; border-radius:8px; image-rendering: pixelated; flex:1; max-width:100%; }
    .hud { font-weight:600; font-size:14px; opacity:0.9; }
    #controls { display:flex; justify-content:space-around; width:100%; padding:10px; background:#222; }
    .btn { background:#444; color:#fff; border:none; padding:20px; flex:1; margin:0 5px; border-radius:10px; font-size:18px; }
    .btn:active { background:#666; }
  </style>
</head>
<body>
<div id="wrap">
  <div class="hud" id="status"></div>
  <canvas id="game" width="900" height="500"></canvas>
  <div id="controls">
    <button class="btn" id="left">‚Üê</button>
    <button class="btn" id="jump">‚§í</button>
    <button class="btn" id="right">‚Üí</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const status = document.getElementById('status');

  const W = canvas.width, H = canvas.height;
  const GRAV = 0.8;
  const FRICTION = 0.85;
  const SPEED = 0.9;
  const MAX_VX = 5.2;
  const JUMP_VY = -13.2;

  const keys = new Set();
  function pressKey(k){ keys.add(k); }
  function releaseKey(k){ keys.delete(k); }

  // Touch controls
  const btnLeft = document.getElementById('left');
  const btnRight = document.getElementById('right');
  const btnJump = document.getElementById('jump');
  btnLeft.addEventListener('touchstart', ()=>pressKey('left'));
  btnLeft.addEventListener('touchend', ()=>releaseKey('left'));
  btnRight.addEventListener('touchstart', ()=>pressKey('right'));
  btnRight.addEventListener('touchend', ()=>releaseKey('right'));
  btnJump.addEventListener('touchstart', ()=>pressKey('jump'));
  btnJump.addEventListener('touchend', ()=>releaseKey('jump'));

  // Keyboard fallback
  window.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 'a' || e.key === 'ArrowLeft') pressKey('left');
    if (e.key.toLowerCase() === 'd' || e.key === 'ArrowRight') pressKey('right');
    if ([' ', 'w', 'ArrowUp'].includes(e.key)) pressKey('jump');
  });
  window.addEventListener('keyup', e => {
    if (e.key.toLowerCase() === 'a' || e.key === 'ArrowLeft') releaseKey('left');
    if (e.key.toLowerCase() === 'd' || e.key === 'ArrowRight') releaseKey('right');
    if ([' ', 'w', 'ArrowUp'].includes(e.key)) releaseKey('jump');
  });

  function rectsOverlap(a,b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  const level = {
    spawn: {x: 40, y: 360},
    platforms: [
      {x:0,y:460,w:2000,h:40, color:'#3a7d44'},
      {x:0,y:420,w:220,h:20, color:'#2ecc71'},
      {x:260,y:370,w:120,h:20, color:'#2ecc71'},
      {x:430,y:330,w:120,h:20, color:'#2ecc71'},
      {x:600,y:300,w:120,h:20, color:'#2ecc71'},
      {x:770,y:260,w:140,h:20, color:'#2ecc71'},
      {x:980,y:370,w:140,h:20, color:'#2ecc71'},
      {x:1200,y:330,w:140,h:20, color:'#2ecc71'},
      {x:1400,y:290,w:140,h:20, color:'#2ecc71'},
      {x:1600,y:250,w:160,h:20, color:'#2ecc71'}
    ],
    enemy: {x: 980, y: 338, w: 30, h: 32, dir: 1, minX: 980, maxX: 1120, speed: 1.6},
    goal:  {x: 1650, y: 210, w: 26, h: 26}
  };

  let camX = 0;
  function centerCameraOn(px) {
    const margin = 200;
    const target = px - (W/2) + margin;
    camX += (target - camX) * 0.06;
    if (camX < 0) camX = 0;
  }

  const player = {
    x: level.spawn.x, y: level.spawn.y, w: 28, h: 36,
    vx: 0, vy: 0, onGround: false, canDouble: true, facing: 1
  };

  let win = false;
  let startTime = performance.now();
  let timeMs = 0;

  function reset() {
    player.x = level.spawn.x; player.y = level.spawn.y;
    player.vx = 0; player.vy = 0; player.onGround = false; player.canDouble = true;
    camX = 0; win = false; startTime = performance.now();
    level.enemy.x = level.enemy.minX; level.enemy.dir = 1;
  }

  function handleInput() {
    const left  = keys.has('left');
    const right = keys.has('right');
    const jumpPressed = keys.has('jump');

    if (left && !right) { player.vx -= SPEED; player.facing = -1; }
    if (right && !left) { player.vx += SPEED; player.facing =  1; }
    if (!(left ^ right)) { player.vx *= FRICTION; if (Math.abs(player.vx) < 0.05) player.vx = 0; }

    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));

    if (jumpPressed && player.onGround) {
      player.vy = JUMP_VY; player.onGround = false; player.canDouble = true;
    } else if (jumpPressed && !player.onGround && player.canDouble) {
      player.vy = JUMP_VY * 0.9; player.canDouble = false;
    }
  }

  function physics() {
    player.vy += GRAV;

    player.x += player.vx;
    for (const p of level.platforms) {
      if (rectsOverlap(player, p)) {
        if (player.vx > 0) player.x = p.x - player.w;
        else if (player.vx < 0) player.x = p.x + p.w;
        player.vx = 0;
      }
    }

    player.y += player.vy;
    let wasOnGround = player.onGround;
    player.onGround = false;
    for (const p of level.platforms) {
      if (rectsOverlap(player, p)) {
        if (player.vy > 0) {
          player.y = p.y - player.h; player.vy = 0; player.onGround = true;
        } else if (player.vy < 0) {
          player.y = p.y + p.h; player.vy = 0;
        }
      }
    }

    if (player.y > H + 200) reset();

    const e = level.enemy;
    e.x += e.speed * e.dir;
    if (e.x < e.minX) { e.x = e.minX; e.dir = 1; }
    if (e.x + e.w > e.maxX) { e.x = e.maxX - e.w; e.dir = -1; }

    if (rectsOverlap(player, e)) {
      if (player.vy > 2 && player.y + player.h - e.y < 16) {
        e.x = -9999; e.w = 0; e.h = 0;
        player.vy = JUMP_VY * 0.7;
      } else {
        reset();
      }
    }

    if (rectsOverlap(player, level.goal)) {
      if (!win) timeMs = performance.now() - startTime;
      win = true;
    }

    centerCameraOn(player.x);
  }

  function draw() {
    ctx.save();
    ctx.translate(-Math.floor(camX), 0);

    for (let i=0;i<6;i++) {
      const bx = i*400;
      ctx.fillStyle = i%2? '#9be2a8' : '#8ed39b';
      ctx.beginPath();
      ctx.ellipse(bx - camX*0.2 + 200, 430, 220, 80, 0, 0, Math.PI*2);
      ctx.fill();
    }

    for (const p of level.platforms) {
      ctx.fillStyle = p.color || '#2ecc71';
      ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.fillStyle = '#1f8a55';
      ctx.fillRect(p.x, p.y, p.w, 4);
    }

    const e = level.enemy;
    if (e.w > 0) {
      ctx.fillStyle = '#e74c3c';
      ctx.fillRect(e.x, e.y, e.w, e.h);
    }

    const g = level.goal;
    ctx.fillStyle = '#f1c40f';
    ctx.beginPath();
    ctx.arc(g.x + g.w/2, g.y + g.h/2, g.w/2, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#b7950b'; ctx.lineWidth = 3;
    ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.fillRect(player.x, player.y, player.w, player.h);

    ctx.restore();

    if (win) {
      status.innerText = `üéâ Gewonnen ‚Äì Zeit: ${(timeMs/1000).toFixed(2)}s`;
    } else {
      const elapsed = ((performance.now() - startTime)/1000).toFixed(2);
      status.innerText = `Zeit: ${elapsed}s`;
    }
  }

  function loop() {
    handleInput();
    physics();
    draw();
    requestAnimationFrame(loop);
  }

  reset();
  loop();
})();
</script>
</body>
</html>
