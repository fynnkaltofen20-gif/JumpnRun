<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Jump'n'Run v4 – Endless</title>
<style>
:root { --ui-h: 120px; }
html, body { margin:0; height:100%; background:#111; color:#fff; font-family: system-ui, Arial, sans-serif; overscroll-behavior: none; }
#wrap { display:flex; flex-direction:column; height:100vh; width:100vw; overflow:hidden; }
#status { padding:8px 10px; font-weight:600; font-size:16px; text-align:center; background:#111; }
#stageWrap { flex:1; position:relative; }
canvas { position:absolute; inset:0; width:100%; height:100%; border-top:2px solid #222; border-bottom:2px solid #222; image-rendering: pixelated; background:#78c0ff; }
#controls { display:flex; gap:10px; align-items:stretch; justify-content:space-between;
            padding:10px; background:#222; height: var(--ui-h); box-sizing: border-box; }
.btn { background:#444; color:#fff; border:none; border-radius:14px; font-size:22px; flex:1;
       display:flex; align-items:center; justify-content:center; }
.btn:active { background:#666; }
#overlay {
  position:absolute; inset:0; background:rgba(0,0,0,0.7);
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  color:white; font-size:24px; font-weight:bold; text-align:center;
}
#overlay button {
  margin-top:20px; padding:10px 20px; font-size:20px; border:none; border-radius:8px;
  background:#28a745; color:white;
}
</style>
</head>
<body>
<div id="wrap">
  <div id="status">Lädt…</div>
  <div id="stageWrap">
    <canvas id="game"></canvas>
    <div id="overlay" style="display:none;">
      <div id="gameOverText">Game Over</div>
      <div id="scoreInfo"></div>
      <button id="restartBtn">Neu starten</button>
    </div>
  </div>
  <div id="controls">
    <button class="btn" id="left">←</button>
    <button class="btn" id="jump">⤒</button>
    <button class="btn" id="right">→</button>
  </div>
</div>

<script>
(() => {
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');
const overlay = document.getElementById('overlay');
const scoreInfo = document.getElementById('scoreInfo');
const restartBtn = document.getElementById('restartBtn');

function resizeCanvas(){
  const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
  const rect = canvas.getBoundingClientRect();
  canvas.width  = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const W = 900, H = 500;
const GRAV = 0.8, FRICTION = 0.85, SPEED = 0.9, MAX_VX = 5.2, JUMP_VY = -13.2;

let keys = new Set();
const pressKey = k => keys.add(k);
const releaseKey = k => keys.delete(k);

["left","right","jump"].forEach(id=>{
  const btn = document.getElementById(id);
  btn.addEventListener('touchstart', e=>{e.preventDefault(); pressKey(id);});
  btn.addEventListener('touchend', e=>{e.preventDefault(); releaseKey(id);});
});
window.addEventListener('keydown', e=>{
  if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') pressKey('left');
  if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') pressKey('right');
  if ([' ', 'w', 'ArrowUp'].includes(e.key)) pressKey('jump');
});
window.addEventListener('keyup', e=>{
  if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') releaseKey('left');
  if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') releaseKey('right');
  if ([' ', 'w', 'ArrowUp'].includes(e.key)) releaseKey('jump');
});

// Entities
let player, platforms, coins, spikes, lavaPools, enemies;
let scrollX, score, coinsCollected, highscore;
let gameOver = false;

highscore = parseInt(localStorage.getItem('highscore') || "0");

function resetGame(){
  player = {x:50, y:360, w:28, h:36, vx:0, vy:0, onGround:false, canDouble:true};
  platforms = [{x:0,y:460,w:300,h:40}];
  coins = [];
  spikes = [];
  lavaPools = [];
  enemies = [];
  scrollX = 0;
  score = 0;
  coinsCollected = 0;
  gameOver = false;
  overlay.style.display = "none";
}

function spawnChunk(){
  const lastPlat = platforms[platforms.length-1];
  let startX = lastPlat.x + lastPlat.w + Math.random()*100 + 50;
  let platW = 120 + Math.random()*100;
  let platY = 300 + Math.random()*120;
  platforms.push({x:startX, y:platY, w:platW, h:20});

  // zufällige Münze
  if (Math.random() < 0.6){
    coins.push({x:startX + platW/2 - 10, y:platY - 30, w:20, h:20});
  }

  // Gegner
  if (Math.random() < 0.3){
    enemies.push({x:startX+platW/3, y:platY-28, w:26, h:28, dir:Math.random()<0.5?-1:1, speed:1.2});
  }

  // Hindernis: Spikes oder Lava
  if (Math.random() < 0.3){
    if (Math.random() < 0.5){
      spikes.push({x:startX + Math.random()*(platW-20), y:platY-20, w:20, h:20});
    } else {
      lavaPools.push({x:startX, y:460, w:platW, h:40});
    }
  }
}

function handleInput(){
  const left = keys.has('left'), right = keys.has('right'), jump = keys.has('jump');
  if (left && !right) { player.vx -= SPEED; }
  if (right && !left) { player.vx += SPEED; }
  if (!(left ^ right)) { player.vx *= FRICTION; if (Math.abs(player.vx)<0.05) player.vx=0; }
  player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));
  if (jump && player.onGround){ player.vy = JUMP_VY; player.onGround=false; player.canDouble=true; }
  else if (jump && !player.onGround && player.canDouble){ player.vy = JUMP_VY*0.9; player.canDouble=false; }
}

function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

function physics(){
  player.vy += GRAV;
  player.x += player.vx;
  player.y += player.vy;
  player.onGround = false;

  for (const p of platforms){
    if (rectsOverlap(player,p)){
      if (player.vy > 0){ player.y = p.y - player.h; player.vy = 0; player.onGround = true; }
      else if (player.vy < 0){ player.y = p.y + p.h; player.vy = 0; }
    }
  }

  // Coins sammeln
  coins = coins.filter(c=>{
    if (rectsOverlap(player,c)){ coinsCollected++; return false; }
    return true;
  });

  // Spikes / Lava
  for (const s of spikes){ if (rectsOverlap(player,s)) return endGame(); }
  for (const l of lavaPools){ if (rectsOverlap(player,l)) return endGame(); }

  // Gegner bewegen & checken
  for (const e of enemies){
    e.x += e.speed * e.dir;
    if (e.x < platforms[0].x) e.dir = 1;
    if (e.x > platforms[platforms.length-1].x) e.dir = -1;
    if (rectsOverlap(player,e)){
      if (player.vy > 2){ // auf Gegner springen
        e.dead = true; player.vy = JUMP_VY*0.7;
      } else return endGame();
    }
  }
  enemies = enemies.filter(e=>!e.dead);

  if (player.y > H+200) return endGame();

  // Scroll & Score
  scrollX = player.x - 200;
  score = Math.floor(scrollX/10) + coinsCollected*10;

  // Neue Plattformen
  if (platforms[platforms.length-1].x < scrollX + W){
    spawnChunk();
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const rect = canvas.getBoundingClientRect();
  const scale = Math.min(rect.width / W, rect.height / H);
  const offX = (rect.width - W*scale)/2;
  const offY = (rect.height - H*scale)/2;
  ctx.save();
  ctx.translate(offX, offY);
  ctx.scale(scale, scale);

  // Hintergrund
  ctx.fillStyle="#78c0ff"; ctx.fillRect(0,0,W,H);
  ctx.fillStyle="#87d37c"; ctx.fillRect(0,H*0.8,W,H*0.2);

  // Plattformen
  ctx.fillStyle="#2ecc71";
  for (const p of platforms){
    ctx.fillRect(p.x - scrollX, p.y, p.w, p.h);
  }

  // Coins
  ctx.fillStyle="gold";
  for (const c of coins){
    ctx.beginPath(); ctx.arc(c.x - scrollX + c.w/2, c.y + c.h/2, c.w/2, 0, Math.PI*2); ctx.fill();
  }

  // Spikes
  ctx.fillStyle="gray";
  for (const s of spikes){
    ctx.beginPath();
    ctx.moveTo(s.x - scrollX, s.y + s.h);
    ctx.lineTo(s.x - scrollX + s.w/2, s.y);
    ctx.lineTo(s.x - scrollX + s.w, s.y + s.h);
    ctx.closePath();
    ctx.fill();
  }

  // Lava
  ctx.fillStyle="#e74c3c";
  for (const l of lavaPools){
    ctx.fillRect(l.x - scrollX, l.y, l.w, l.h);
  }

  // Gegner
  ctx.fillStyle="#ff5733";
  for (const e of enemies){
    ctx.fillRect(e.x - scrollX, e.y, e.w, e.h);
  }

  // Spieler
  ctx.fillStyle="#333";
  ctx.fillRect(player.x - scrollX, player.y, player.w, player.h);

  ctx.restore();
  status.textContent = `Distanz: ${Math.floor(scrollX/10)}  | Coins: ${coinsCollected} | Score: ${score} | Highscore: ${highscore}`;
}

function endGame(){
  gameOver = true;
  if (score > highscore){
    highscore = score;
    localStorage.setItem('highscore', highscore);
  }
  scoreInfo.textContent = `Score: ${score} | Highscore: ${highscore}`;
  overlay.style.display = "flex";
}

function gameLoop(){
  if (!gameOver){
    handleInput();
    physics();
    draw();
    requestAnimationFrame(gameLoop);
  } else {
    draw();
  }
}

restartBtn.addEventListener('click', ()=>{
  resetGame();
  gameLoop();
});

resetGame();
for (let i=0;i<5;i++) spawnChunk();
gameLoop();
})();
</script>
</body>
</html>
