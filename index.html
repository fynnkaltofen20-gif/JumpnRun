<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Mini Jump 'n' Run ‚Äì Mobile v3</title>
  <style>
    :root { --ui-h: 120px; }
    html, body { margin: 0; height: 100%; background:#111; color:#eee; font-family: system-ui, Arial, sans-serif; overscroll-behavior: none; }
    #wrap { display:flex; flex-direction:column; height:100vh; width:100vw; overflow:hidden; }
    #status { padding:8px 10px; font-weight:600; font-size:16px; text-align:center; background:#111; }
    #stageWrap { flex:1; position:relative; }
    canvas { position:absolute; inset:0; width:100%; height:100%; border-top:2px solid #222; border-bottom:2px solid #222; image-rendering: pixelated; background:#78c0ff; }
    #controls { display:flex; gap:10px; align-items:stretch; justify-content:space-between;
                padding:10px; background:#222; height: var(--ui-h); box-sizing: border-box; }
    .btn { background:#444; color:#fff; border:none; border-radius:14px; font-size:22px; flex:1;
           display:flex; align-items:center; justify-content:center; }
    .btn:active { background:#666; }
  </style>
</head>
<body>
<div id="wrap">
  <div id="status">L√§dt‚Ä¶</div>
  <div id="stageWrap">
    <canvas id="game"></canvas>
  </div>
  <div id="controls">
    <button class="btn" id="left">‚Üê</button>
    <button class="btn" id="jump">‚§í</button>
    <button class="btn" id="right">‚Üí</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const status = document.getElementById('status');

  function resizeCanvas(){
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  const W = 900, H = 500;
  const GRAV = 0.8, FRICTION = 0.85, SPEED = 0.9, MAX_VX = 5.2, JUMP_VY = -13.2;

  const keys = new Set();
  const pressKey = k => keys.add(k);
  const releaseKey = k => keys.delete(k);

  const btnLeft  = document.getElementById('left');
  const btnRight = document.getElementById('right');
  const btnJump  = document.getElementById('jump');
  const passive = {passive:false};
  btnLeft.addEventListener('touchstart', e=>{e.preventDefault(); pressKey('left');}, passive);
  btnLeft.addEventListener('touchend',   e=>{e.preventDefault(); releaseKey('left');}, passive);
  btnRight.addEventListener('touchstart',e=>{e.preventDefault(); pressKey('right');}, passive);
  btnRight.addEventListener('touchend',  e=>{e.preventDefault(); releaseKey('right');}, passive);
  btnJump.addEventListener('touchstart', e=>{e.preventDefault(); pressKey('jump');}, passive);
  btnJump.addEventListener('touchend',   e=>{e.preventDefault(); releaseKey('jump');}, passive);

  window.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 'a' || e.key === 'ArrowLeft')  pressKey('left');
    if (e.key.toLowerCase() === 'd' || e.key === 'ArrowRight') pressKey('right');
    if ([' ', 'w', 'ArrowUp'].includes(e.key))                 pressKey('jump');
  });
  window.addEventListener('keyup', e => {
    if (e.key.toLowerCase() === 'a' || e.key === 'ArrowLeft')  releaseKey('left');
    if (e.key.toLowerCase() === 'd' || e.key === 'ArrowRight') releaseKey('right');
    if ([' ', 'w', 'ArrowUp'].includes(e.key))                 releaseKey('jump');
  });

  const level = {
    spawn: {x: 40, y: 360},
    platforms: [
      {x:0,y:460,w:2000,h:40, color:'#3a7d44'},
      {x:0,y:420,w:220,h:20, color:'#2ecc71'},
      {x:260,y:370,w:120,h:20, color:'#2ecc71'},
      {x:430,y:330,w:120,h:20, color:'#2ecc71'},
      {x:600,y:300,w:120,h:20, color:'#2ecc71'},
      {x:770,y:260,w:140,h:20, color:'#2ecc71'},
      {x:980,y:370,w:140,h:20, color:'#2ecc71'},
      {x:1200,y:330,w:140,h:20, color:'#2ecc71'},
      {x:1400,y:290,w:140,h:20, color:'#2ecc71'},
      {x:1600,y:250,w:160,h:20, color:'#2ecc71'}
    ],
    enemy: {x: 980, y: 338, w: 30, h: 32, dir: 1, minX: 980, maxX: 1120, speed: 1.6},
    goal:  {x: 1650, y: 210, w: 26, h: 26}
  };

  let camX = 0;
  function centerCameraOn(px) {
    const target = px - (W/2) + 200;
    camX += (target - camX) * 0.06;
    if (camX < 0) camX = 0;
  }

  const player = {x:level.spawn.x, y:level.spawn.y, w:28, h:36, vx:0, vy:0, onGround:false, canDouble:true, facing:1};
  let win = false, startTime = performance.now(), timeMs = 0;

  function reset(){
    Object.assign(player, {x:level.spawn.x, y:level.spawn.y, vx:0, vy:0, onGround:false, canDouble:true});
    camX = 0; win = false; startTime = performance.now();
    level.enemy.x = level.enemy.minX; level.enemy.dir = 1;
  }

  function handleInput(){
    const left = keys.has('left'), right = keys.has('right'), jump = keys.has('jump');
    if (left && !right){ player.vx -= SPEED; player.facing = -1; }
    if (right && !left){ player.vx += SPEED; player.facing = 1; }
    if (!(left ^ right)){ player.vx *= FRICTION; if (Math.abs(player.vx) < 0.05) player.vx = 0; }
    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));
    if (jump && player.onGround){ player.vy = JUMP_VY; player.onGround = false; player.canDouble = true; }
    else if (jump && !player.onGround && player.canDouble){ player.vy = JUMP_VY * 0.9; player.canDouble = false; }
  }

  function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

  function physics(){
    player.vy += GRAV;
    player.x += player.vx;
    for (const p of level.platforms){
      if (rectsOverlap(player, p)){
        if (player.vx > 0) player.x = p.x - player.w;
        else if (player.vx < 0) player.x = p.x + p.w;
        player.vx = 0;
      }
    }
    player.y += player.vy;
    player.onGround = false;
    for (const p of level.platforms){
      if (rectsOverlap(player, p)){
        if (player.vy > 0){ player.y = p.y - player.h; player.vy = 0; player.onGround = true; }
        else if (player.vy < 0){ player.y = p.y + p.h; player.vy = 0; }
      }
    }
    if (player.y > H+200) reset();

    const e = level.enemy;
    e.x += e.speed * e.dir;
    if (e.x < e.minX){ e.x = e.minX; e.dir = 1; }
    if (e.x + e.w > e.maxX){ e.x = e.maxX - e.w; e.dir = -1; }
    if (rectsOverlap(player, e)){
      if (player.vy > 2 && player.y + player.h - e.y < 16){
        e.x = -9999; e.w = 0; e.h = 0; player.vy = JUMP_VY * 0.7;
      } else reset();
    }

    if (rectsOverlap(player, level.goal)){ if (!win) timeMs = performance.now() - startTime; win = true; }

    centerCameraOn(player.x);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const rect = canvas.getBoundingClientRect();
    const scale = Math.min(rect.width / W, rect.height / H);
    const offX = Math.floor((rect.width - W*scale)/2);
    const offY = Math.floor((rect.height - H*scale)/2);
    ctx.save();
    ctx.translate(offX, offY);
    ctx.scale(scale, scale);

    // Hintergrund
    ctx.fillStyle = "#78c0ff"; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "#b1e1ff"; ctx.fillRect(0,H*0.4,W,H*0.6);
    ctx.fillStyle = "#87d37c"; ctx.fillRect(0,H*0.4,W,H*0.6);
    ctx.fillStyle = "#6ab04c"; ctx.fillRect(0,H*0.8,W,H*0.2);

    for (let i=0;i<6;i++){
      const bx = i*400;
      ctx.fillStyle = i%2? '#9be2a8' : '#8ed39b';
      ctx.beginPath();
      ctx.ellipse(bx - camX*0.2 + 200, 430, 220, 90, 0, 0, Math.PI*2);
      ctx.fill();
    }

    for (const p of level.platforms){
      ctx.fillStyle = p.color || '#2ecc71';
      ctx.fillRect(Math.round(p.x), Math.round(p.y), Math.round(p.w), Math.round(p.h));
      ctx.fillStyle = '#1f8a55';
      ctx.fillRect(Math.round(p.x), Math.round(p.y), Math.round(p.w), 5);
    }

    const e = level.enemy;
    if (e.w > 0){ ctx.fillStyle = '#e74c3c'; ctx.fillRect(Math.round(e.x), Math.round(e.y), e.w, e.h); }

    const g = level.goal;
    ctx.fillStyle = '#f1c40f';
    ctx.beginPath(); ctx.arc(g.x + g.w/2, g.y + g.h/2, g.w/2, 0, Math.PI*2); ctx.fill();
    ctx.lineWidth = 3; ctx.strokeStyle = '#b7950b'; ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.fillRect(Math.round(player.x), Math.round(player.y), player.w, player.h);

    ctx.restore();

    status.textContent = win ? `üéâ Gewonnen ‚Äì Zeit: ${(timeMs/1000).toFixed(2)}s`
                             : `Zeit: ${((performance.now() - startTime)/1000).toFixed(2)}s`;
  }

  function loop(){ handleInput(); physics(); draw(); requestAnimationFrame(loop); }
  reset(); loop();
})();
</script>
</body>
</html>
